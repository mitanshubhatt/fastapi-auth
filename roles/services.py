from fastapi import HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from typing import Optional

from roles.dao import RoleDAO
from roles.schemas import RoleCreate
from roles.models import Role
from utils.custom_logger import logger


class RoleService:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.role_dao = RoleDAO(db)

    async def create_role(self, role_data: RoleCreate) -> Role:
        """
        Service method to create a new role.
        Handles business logic like checking for existing roles by name/slug.
        """
        # Pydantic's RoleCreate schema already handles slug generation if not provided
        # and basic validation.

        # DAO's create_role will check for existing name/slug and return existing if found
        # or create a new one.
        try:
            # The DAO method is designed to return existing if name/slug conflict.
            # We need to decide if this service should treat that as an error (409) or success.
            # Let's assume creating an already existing role (by unique name/slug) is a conflict.

            # First, check explicitly to provide a clearer 409 message if needed.
            existing_by_name = await self.role_dao.get_role_by_name(role_data.name)
            if existing_by_name:
                logger.warning(f"Create role failed: name '{role_data.name}' already exists.")
                raise HTTPException(
                    status_code=status.HTTP_409_CONFLICT,
                    detail=f"Role with name '{role_data.name}' already exists."
                )

            # The slug is generated by Pydantic if None, or validated if provided.
            # The Pydantic validator ensures role_data.slug is not None here.
            if role_data.slug:  # Should always be true due to Pydantic validator
                existing_by_slug = await self.role_dao.get_role_by_slug(role_data.slug)
                if existing_by_slug:
                    logger.warning(f"Create role failed: slug '{role_data.slug}' already exists.")
                    raise HTTPException(
                        status_code=status.HTTP_409_CONFLICT,
                        detail=f"Role with slug '{role_data.slug}' already exists."
                    )

            created_role = await self.role_dao.create_role(
                name=role_data.name,
                scope=role_data.scope,
                slug=role_data.slug,  # Slug is now guaranteed by Pydantic model
                description=role_data.description
            )
            # The DAO might still raise IntegrityError for race conditions,
            # or return None if slug generation failed (though Pydantic should catch this).
            if not created_role:
                # This case should be rare if Pydantic validation is robust
                logger.error("Role creation in DAO returned None unexpectedly after passing initial checks.")
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail="Failed to create role due to an unexpected issue."
                )
            return created_role
        except IntegrityError:  # Handles race conditions where DB catches uniqueness first
            logger.warning(
                f"Database integrity error during role creation for name '{role_data.name}'. Potentially a race condition.")
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="A role with this name or slug already exists (encountered race condition)."
            )
        except ValueError as ve:  # Catch specific ValueErrors from DAO (e.g. slug generation)
            logger.error(f"Validation error during role creation: {ve}")
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(ve))
        except Exception as e:
            logger.error(f"Unexpected error in RoleService.create_role: {e}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="An unexpected error occurred while creating the role."
            )

    async def get_role_by_id(self, role_id: int) -> Optional[Role]:
        """Service method to fetch a role by its ID."""
        role = await self.role_dao.get_role_by_id(role_id)
        if not role:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
        return role

    async def get_role_by_slug(self, slug: str) -> Optional[Role]:
        """Service method to fetch a role by its slug."""
        role = await self.role_dao.get_role_by_slug(slug)
        if not role:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
        return role


